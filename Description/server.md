# Сетевая часть игры

**Замечание** Данная статья будет обновляться и дополняться со временем и несет лишь примерный характер.

## Клиент-серверная архитектура
Наше приложение будет реализовывать клиент-серверную архитектуру. Это значит, что мы должны написать два приложения:
1. Клиентское приложение - то, которое и будет запускаться на смартфонах наших пользователей. Это приложение должно хранить модель представления данных игровой сессии, и осуществлять их отрисовку на экраны смартфона.
2. Серверное приложение - то, которое будет запускаться на отдельном VPS (предоставляемым платформой heroku.com). Оно не будет осуществлять никакой отрисовки. Оно будет:
   * Вычислительным, то есть осуществляет расчет всех параметров игровой сессии (положение мяча, состояние замков игроков и пр.). 
   * Посредником между двумя игроками. Оно реализует систему, управляемую сообщениями. Это значит, что оно *получает* события (некоторый объект события со своими метаданными) от клиентов (выстрел, постройка блока, и прочие активности), и *отправляет* события (отправлять события - не очень удачный термин, наверное) своим двум клиентам.

**Замечание** Оба этих приложения будут реализованы на языке Java, поскольку они оба имеют прямое отношение к игровой сессии, и их взаимодействие будет реализовано на низкоуровневых протоколах (tcp/udp), используя такой системный объект, как *Socket*.

Клиент-серверная архитектура будет реализована с помощью библиотек java.nio и java.netty (скорее всего, одной из них), с помощью объектов Socket (из java.nio) и Connection (из netty). Приложение не обязано быть многопоточным из-за неблокирующего обмена сообщениями по сети из библеотеки java.nio. Однако, если обнаружатся явные проблемы использования java.nio на платформе Android, придется пользоватся java.net + java.io в отдельном потоке, поскольку они предоставляют блокирующие поток операции.  Более подробное описание **будет позже**, после построения интерфейсной архитектуры приложения. 

**Замечание**
Данными будем обмениваться по UDP протоколу, поскольку нам важнее скорость работы сети против точности переданных данных.

## Создание игровых сессий
Отдельная тема, которую стоит рассмотреть, это соединение игроков друг с другом. В современном мире существует два основных способа нахождения игроками игровых сессий:
1. Лобби - на нашем VPS будет крутиться несколько instance'ов (экземпляров) нашего приложения (предположительно в docker контейнерах или, более преемущественно, в k8s кластере). Тогда необходима реализация отдельного приложение - *lobby master*, который будет реализовывать API работы с лобби (создание нового лобби, подключение к существующему лобби, получение информации о лобби, удаление лобби, может быть что-нибудь еще). Это приложение и будет создавать экземпляры серверного приложения с заданными IP адресами игроков, иначе говоря создавать новую игровую сессию.
2. Матчмейкинг - игроки делают запрос на подбор игроков (в нашем случае игрока) и ждут, пока не будет найден соперник(и). Это значит, что также требуется реализация отдельного приложения *matchmaker*, отвечающего за распределение игроков по игровым сессиям. Как только найдется достаточное количество игроков (в нашем случае это всего еще один игрок), приложение создает новый экземпляр серверного приложения. Это приложение может быть "надстройкой" над приложением *lobby master*, но может и не быть. 

В нашем приложении будет последовательно реализовано оба приложения (если это не станет невозможным из-за временных рамок). Сначала *lobby master*, потом *matchmaker*. 

## Lobby master
Как уже было сказано - это приложение, отвечающее за создание/удаление/изменение лобби, подключение к лобби. 
Самое очевидное решение - это REST сервер, принимающий/отдающий HTTP запросы, семантика которых - уже упомянутые операции с лобби. Более подробное описание *lobby master* - **будет позже**.

**Замечание** Этот сервер может быть реализован на любом удобном языке, и Java среди них - не самый удобный. Это связано с тем, что приложение *lobby master* не имеет ничего общего с игровыми сессиями, а занимается лишь созданием экземпляров серверных приложений. Тем не менее, оно хранит свои собственные метаданные о текущем состоянии лобби (очень грубо - массив из лобби).

## Matchmaker 
Аккуратное написание собственного *matchmaker*'а, с такими возможностям, как подбор игроков "вокруг" (недалеко от того, кто ищет) и прочими прелестями современных матчмейкеров - является достаточно трудоемким и не вписывается в семестровый курс. Поэтому мы будем пользоваться готовым решение от Google - *Open Match*. Оно поставляется как готовые helm-пакеты (чарты) для k8s-кластера. Более подробное описание работы *matchmaker* - **будет позже**.

## Инфраструктура
В связи с рассмотренной архитектурой требуется описать инфраструктуру всех частей проекта. Это будет, скорее всего, комбинация *Google Cloud Platform* и *Heroku*, как самых доступных по цене платформ, то есть бесплатно на некоторый срок. Подробное описание инфраструктуры **будет позже**.